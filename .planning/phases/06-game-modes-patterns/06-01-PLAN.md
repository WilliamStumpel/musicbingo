---
phase: 06-game-modes-patterns
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - musicbingo_api/src/musicbingo_api/models.py
  - musicbingo_host/src/components/PatternSelector.jsx
autonomous: true
---

<objective>
Complete bingo pattern support with Frame pattern and expose all patterns in UI.

Purpose: Enable DJ to select from all 8 bingo patterns (5-in-a-row, row, column, diagonal, four corners, X, blackout, frame) with proper backend validation and frontend selection.

Output: Full pattern coverage in both backend validation and frontend UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Backend pattern implementation (has 7 patterns, missing Frame)
@musicbingo_api/src/musicbingo_api/models.py

# Frontend pattern selector (shows 4 of 8 patterns)
@musicbingo_host/src/components/PatternSelector.jsx

# Frontend pattern display (already has Frame)
@musicbingo_host/src/components/PatternDisplay.jsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Frame pattern to backend</name>
  <files>musicbingo_api/src/musicbingo_api/models.py</files>
  <action>
Add FRAME to PatternType enum after X_PATTERN:
```python
FRAME = "frame"
```

Add check_win logic in BingoPattern.check_win() method after FULL_CARD case:
```python
elif self.pattern_type == PatternType.FRAME:
    # All edge cells (top row, bottom row, left column, right column)
    frame_positions = set()
    for i in range(5):
        frame_positions.add((0, i))  # Top row
        frame_positions.add((4, i))  # Bottom row
        frame_positions.add((i, 0))  # Left column
        frame_positions.add((i, 4))  # Right column
    return frame_positions.issubset(marked_positions)
```

Add to DEFAULT_PATTERNS dict:
```python
PatternType.FRAME: BingoPattern(
    PatternType.FRAME, "Frame", "Complete the outer border"
),
```
  </action>
  <verify>python -c "from musicbingo_api.models import PatternType, DEFAULT_PATTERNS; print(PatternType.FRAME); print(DEFAULT_PATTERNS[PatternType.FRAME])"</verify>
  <done>PatternType.FRAME exists, DEFAULT_PATTERNS includes Frame, check_win handles frame pattern</done>
</task>

<task type="auto">
  <name>Task 2: Expose all 8 patterns in PatternSelector UI</name>
  <files>musicbingo_host/src/components/PatternSelector.jsx</files>
  <action>
Update PATTERN_OPTIONS array to include all 8 patterns that match backend PatternType enum:
```javascript
const PATTERN_OPTIONS = [
  { value: 'five_in_a_row', label: '5 in a Row', description: 'Row, column, or diagonal' },
  { value: 'row', label: 'Any Row', description: 'Any horizontal row' },
  { value: 'column', label: 'Any Column', description: 'Any vertical column' },
  { value: 'diagonal', label: 'Diagonal', description: 'Either diagonal' },
  { value: 'four_corners', label: '4 Corners', description: 'All four corners' },
  { value: 'x_pattern', label: 'X Pattern', description: 'Both diagonals' },
  { value: 'frame', label: 'Frame', description: 'Outer border' },
  { value: 'full_card', label: 'Blackout', description: 'All 24 squares' },
];
```
Order: from easiest to hardest (5-in-a-row → row → column → diagonal → 4 corners → X → frame → blackout).
  </action>
  <verify>cd musicbingo_host && npm run build</verify>
  <done>PatternSelector shows all 8 patterns in dropdown, build succeeds</done>
</task>

<task type="auto">
  <name>Task 3: Add missing patterns to PatternDisplay</name>
  <files>musicbingo_host/src/components/PatternDisplay.jsx</files>
  <action>
Update PATTERNS object to include row, column, and diagonal patterns that are now exposed in UI:
```javascript
const PATTERNS = {
  five_in_a_row: {
    label: '5 in a Row',
    cells: [[0, 2], [1, 2], [2, 2], [3, 2], [4, 2]]
  },
  row: {
    label: 'Any Row',
    cells: [[0, 2], [1, 2], [2, 2], [3, 2], [4, 2]]
  },
  column: {
    label: 'Any Column',
    cells: [[2, 0], [2, 1], [2, 2], [2, 3], [2, 4]]
  },
  diagonal: {
    label: 'Diagonal',
    cells: [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]
  },
  four_corners: {
    label: '4 Corners',
    cells: [[0, 0], [4, 0], [0, 4], [4, 4]]
  },
  x_pattern: {
    label: 'X Pattern',
    cells: [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4], [4, 0], [3, 1], [1, 3], [0, 4]]
  },
  frame: {
    label: 'Frame',
    cells: 'border'
  },
  full_card: {
    label: 'Blackout',
    cells: 'all'
  }
};
```
The row/column/diagonal visualizations show example patterns (middle row, middle column, main diagonal).
  </action>
  <verify>cd musicbingo_host && npm run build</verify>
  <done>PatternDisplay shows visual grid for all 8 patterns, build succeeds</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Backend: `python -c "from musicbingo_api.models import PatternType; print([p.value for p in PatternType])"` shows all 8 patterns including 'frame'
- [ ] Backend: Frame pattern validation works (unit test or manual check)
- [ ] Frontend: `npm run build` in musicbingo_host succeeds
- [ ] Frontend: PatternSelector dropdown shows 8 options
- [ ] Frontend: PatternDisplay renders all 8 patterns correctly
</verification>

<success_criteria>
- All 8 patterns defined in backend PatternType enum
- All 8 patterns have check_win logic in BingoPattern
- All 8 patterns appear in PatternSelector dropdown
- All 8 patterns render correctly in PatternDisplay
- Build succeeds for both backend and frontend
</success_criteria>

<output>
After completion, create `.planning/phases/06-game-modes-patterns/06-01-SUMMARY.md`
</output>
