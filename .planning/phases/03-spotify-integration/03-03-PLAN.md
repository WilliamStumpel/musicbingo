---
phase: 03-manual-playback
plan: 03
type: execute
wave: 2
depends_on: ["03-04"]
files_modified:
  - musicbingo_verify/src/App.js
  - musicbingo_verify/src/App.css
  - musicbingo_verify/src/components/SongChecklist.jsx
  - musicbingo_verify/src/components/SongChecklist.css
  - musicbingo_verify/src/components/TabBar.jsx
  - musicbingo_verify/src/components/TabBar.css
  - musicbingo_verify/src/hooks/useGameState.js
  - musicbingo_verify/src/services/gameApi.js
autonomous: true
---

<objective>
Add song checklist view to the scanner PWA for marking songs as played.

Purpose: Allow the DJ to mark songs from their phone (scanner) in addition to the host laptop. Complements QR scanning with manual song tracking.

Output: Scanner PWA has two tabs: Scan (existing) and Checklist (new). Same sort/search/mark features as host app.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-spotify-integration/DISCOVERY.md
@musicbingo_verify/src/App.js
@musicbingo_verify/src/components/Scanner.jsx
@musicbingo_host/src/components/SongChecklist.jsx (reference for consistency)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create game API service for scanner</name>
  <files>musicbingo_verify/src/services/gameApi.js</files>
  <action>
Create gameApi.js service (uses existing config.js for API URL):

```javascript
/**
 * Game API service for communicating with the backend.
 */

import { getApiUrl } from '../config';

/**
 * Get list of available games.
 */
export async function getGames() {
  const response = await fetch(`${getApiUrl()}/api/games`);
  if (!response.ok) throw new Error('Failed to fetch games');
  const data = await response.json();
  return data.games || [];
}

/**
 * Load a game by filename.
 */
export async function loadGame(filename) {
  const response = await fetch(`${getApiUrl()}/api/games/load/${filename}`, {
    method: 'POST'
  });
  if (!response.ok) throw new Error('Failed to load game');
  return response.json();
}

/**
 * Get current game state (played songs, etc.).
 */
export async function getGameState(gameId) {
  const response = await fetch(`${getApiUrl()}/api/game/${gameId}/state`);
  if (!response.ok) {
    if (response.status === 404) {
      return { played_songs: [] };
    }
    throw new Error('Failed to get game state');
  }
  return response.json();
}

/**
 * Mark a song as played or unplayed.
 */
export async function markSongPlayed(gameId, songId, played = true) {
  const response = await fetch(`${getApiUrl()}/api/game/${gameId}/mark-song`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ song_id: songId, played })
  });
  if (!response.ok) throw new Error('Failed to mark song');
  return response.json();
}

/**
 * Poll for game state updates.
 */
export async function pollGameState(gameId) {
  try {
    const state = await getGameState(gameId);
    return state.played_songs || [];
  } catch (e) {
    console.error('Poll failed:', e);
    return null;
  }
}
```
  </action>
  <verify>File created without syntax errors</verify>
  <done>Game API service created for scanner</done>
</task>

<task type="auto">
  <name>Task 2: Create useGameState hook for scanner</name>
  <files>musicbingo_verify/src/hooks/useGameState.js</files>
  <action>
Create useGameState.js hook (same as host app):

```javascript
import { useState, useEffect, useCallback, useRef } from 'react';
import * as gameApi from '../services/gameApi';

const POLL_INTERVAL = 2000; // 2 seconds

export function useGameState() {
  const [games, setGames] = useState([]);
  const [currentGame, setCurrentGame] = useState(null);
  const [songs, setSongs] = useState([]);
  const [playedSongs, setPlayedSongs] = useState(new Set());
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  const pollRef = useRef(null);
  const gameIdRef = useRef(null);

  // Load available games
  const loadGames = useCallback(async () => {
    try {
      const gameList = await gameApi.getGames();
      setGames(gameList);
    } catch (e) {
      setError(e.message);
    }
  }, []);

  // Load a specific game
  const loadGame = useCallback(async (filename) => {
    setIsLoading(true);
    setError(null);

    try {
      const game = await gameApi.loadGame(filename);
      setCurrentGame(game);
      setSongs(game.songs || []);
      gameIdRef.current = game.game_id;

      // Get initial state
      const state = await gameApi.getGameState(game.game_id);
      setPlayedSongs(new Set(state.played_songs || []));
    } catch (e) {
      setError(e.message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Toggle song played status
  const toggleSongPlayed = useCallback(async (songId) => {
    const gameId = gameIdRef.current;
    if (!gameId) return;

    const isPlayed = playedSongs.has(songId);
    const newPlayed = !isPlayed;

    // Optimistic update
    setPlayedSongs(prev => {
      const next = new Set(prev);
      if (newPlayed) {
        next.add(songId);
      } else {
        next.delete(songId);
      }
      return next;
    });

    // Sync to API
    try {
      await gameApi.markSongPlayed(gameId, songId, newPlayed);
    } catch (e) {
      // Revert on error
      setPlayedSongs(prev => {
        const next = new Set(prev);
        if (newPlayed) {
          next.delete(songId);
        } else {
          next.add(songId);
        }
        return next;
      });
      setError(e.message);
    }
  }, [playedSongs]);

  // Start polling for updates
  useEffect(() => {
    if (!gameIdRef.current) return;

    const poll = async () => {
      const played = await gameApi.pollGameState(gameIdRef.current);
      if (played !== null) {
        setPlayedSongs(new Set(played));
      }
    };

    pollRef.current = setInterval(poll, POLL_INTERVAL);

    return () => {
      if (pollRef.current) {
        clearInterval(pollRef.current);
      }
    };
  }, [currentGame]);

  // Load games on mount
  useEffect(() => {
    loadGames();
  }, [loadGames]);

  const playedCount = playedSongs.size;
  const totalCount = songs.length;

  return {
    games,
    currentGame,
    songs,
    playedSongs,
    playedCount,
    totalCount,
    isLoading,
    error,
    loadGame,
    toggleSongPlayed,
    refreshGames: loadGames,
  };
}
```
  </action>
  <verify>Hook imports without errors</verify>
  <done>useGameState hook created for scanner</done>
</task>

<task type="auto">
  <name>Task 3: Create SongChecklist component for scanner</name>
  <files>musicbingo_verify/src/components/SongChecklist.jsx, musicbingo_verify/src/components/SongChecklist.css</files>
  <action>
1. Create SongChecklist.jsx (same logic as host, mobile-optimized styling):

```jsx
import React, { useState, useMemo } from 'react';
import './SongChecklist.css';

const SORT_OPTIONS = {
  TITLE_ASC: { field: 'title', dir: 'asc', label: 'Title A-Z' },
  TITLE_DESC: { field: 'title', dir: 'desc', label: 'Title Z-A' },
  ARTIST_ASC: { field: 'artist', dir: 'asc', label: 'Artist A-Z' },
  ARTIST_DESC: { field: 'artist', dir: 'desc', label: 'Artist Z-A' },
};

export function SongChecklist({
  songs,
  playedSongs,
  onTogglePlayed,
  playedCount,
  totalCount,
}) {
  const [searchQuery, setSearchQuery] = useState('');
  const [sortKey, setSortKey] = useState('TITLE_ASC');

  const displayedSongs = useMemo(() => {
    let result = [...songs];

    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      result = result.filter(song =>
        song.title.toLowerCase().includes(query) ||
        song.artist.toLowerCase().includes(query)
      );
    }

    const sort = SORT_OPTIONS[sortKey];
    result.sort((a, b) => {
      const aVal = a[sort.field].toLowerCase();
      const bVal = b[sort.field].toLowerCase();
      const cmp = aVal.localeCompare(bVal);
      return sort.dir === 'asc' ? cmp : -cmp;
    });

    return result;
  }, [songs, searchQuery, sortKey]);

  return (
    <div className="song-checklist">
      <div className="checklist-header">
        <div className="stats">
          <span className="played-count">{playedCount}</span>
          <span className="total-count">/ {totalCount} played</span>
        </div>
      </div>

      <div className="checklist-controls">
        <div className="search-box">
          <input
            type="text"
            placeholder="Search songs..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="search-input"
          />
          {searchQuery && (
            <button
              className="clear-search"
              onClick={() => setSearchQuery('')}
            >
              Ã—
            </button>
          )}
        </div>

        <select
          value={sortKey}
          onChange={(e) => setSortKey(e.target.value)}
          className="sort-select"
        >
          {Object.entries(SORT_OPTIONS).map(([key, opt]) => (
            <option key={key} value={key}>{opt.label}</option>
          ))}
        </select>
      </div>

      <div className="song-list">
        {displayedSongs.map(song => {
          const isPlayed = playedSongs.has(song.song_id);
          return (
            <div
              key={song.song_id}
              className={`song-row ${isPlayed ? 'played' : ''}`}
              onClick={() => onTogglePlayed(song.song_id)}
            >
              <div className="played-indicator">
                {isPlayed ? 'âœ“' : 'â—‹'}
              </div>
              <div className="song-info">
                <div className="song-title">{song.title}</div>
                <div className="song-artist">{song.artist}</div>
              </div>
            </div>
          );
        })}

        {displayedSongs.length === 0 && searchQuery && (
          <div className="no-results">
            No songs match "{searchQuery}"
          </div>
        )}

        {songs.length === 0 && (
          <div className="empty-state">
            Select a game to load songs
          </div>
        )}
      </div>
    </div>
  );
}
```

2. Create SongChecklist.css (mobile-optimized):

```css
.song-checklist {
  display: flex;
  flex-direction: column;
  height: 100%;
  background: #1a1a2e;
  overflow: hidden;
}

.checklist-header {
  padding: 12px 16px;
  border-bottom: 1px solid #2d2d44;
}

.stats {
  font-size: 16px;
}

.played-count {
  font-weight: bold;
  color: #00d26a;
  font-size: 22px;
}

.total-count {
  color: #888;
}

.checklist-controls {
  padding: 10px 12px;
  display: flex;
  gap: 8px;
  border-bottom: 1px solid #2d2d44;
  background: #16162b;
}

.search-box {
  flex: 1;
  position: relative;
}

.search-input {
  width: 100%;
  padding: 10px 32px 10px 12px;
  background: #2d2d44;
  border: 1px solid #3d3d5c;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  -webkit-appearance: none;
}

.search-input:focus {
  outline: none;
  border-color: #00d26a;
}

.search-input::placeholder {
  color: #666;
}

.clear-search {
  position: absolute;
  right: 6px;
  top: 50%;
  transform: translateY(-50%);
  background: none;
  border: none;
  color: #888;
  font-size: 20px;
  padding: 4px 8px;
  cursor: pointer;
}

.sort-select {
  padding: 10px 8px;
  background: #2d2d44;
  border: 1px solid #3d3d5c;
  border-radius: 8px;
  color: #fff;
  font-size: 14px;
  min-width: 100px;
  -webkit-appearance: none;
}

.song-list {
  flex: 1;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.song-row {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 14px 16px;
  border-bottom: 1px solid #2d2d44;
  cursor: pointer;
  transition: background 0.15s ease;
  -webkit-tap-highlight-color: rgba(0, 210, 106, 0.1);
}

.song-row:active {
  background: #2d2d44;
}

.song-row.played {
  opacity: 0.55;
}

.song-row.played .song-title {
  text-decoration: line-through;
  color: #666;
}

.played-indicator {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  color: #555;
  border: 2px solid #3d3d5c;
  border-radius: 50%;
  flex-shrink: 0;
}

.song-row.played .played-indicator {
  background: #00d26a;
  border-color: #00d26a;
  color: #fff;
}

.song-info {
  flex: 1;
  min-width: 0;
}

.song-title {
  font-size: 15px;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.song-artist {
  font-size: 13px;
  color: #888;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  margin-top: 2px;
}

.no-results,
.empty-state {
  padding: 40px 20px;
  text-align: center;
  color: #666;
}
```
  </action>
  <verify>Component renders without errors</verify>
  <done>SongChecklist component created for scanner</done>
</task>

<task type="auto">
  <name>Task 4: Create TabBar component</name>
  <files>musicbingo_verify/src/components/TabBar.jsx, musicbingo_verify/src/components/TabBar.css</files>
  <action>
1. Create TabBar.jsx:

```jsx
import React from 'react';
import './TabBar.css';

export function TabBar({ activeTab, onTabChange }) {
  return (
    <div className="tab-bar">
      <button
        className={`tab-button ${activeTab === 'scan' ? 'active' : ''}`}
        onClick={() => onTabChange('scan')}
      >
        <span className="tab-icon">ðŸ“·</span>
        <span className="tab-label">Scan</span>
      </button>
      <button
        className={`tab-button ${activeTab === 'checklist' ? 'active' : ''}`}
        onClick={() => onTabChange('checklist')}
      >
        <span className="tab-icon">âœ“</span>
        <span className="tab-label">Songs</span>
      </button>
    </div>
  );
}
```

2. Create TabBar.css:

```css
.tab-bar {
  display: flex;
  background: #16162b;
  border-top: 1px solid #2d2d44;
  padding-bottom: env(safe-area-inset-bottom);
}

.tab-button {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
  padding: 10px 0;
  background: none;
  border: none;
  color: #666;
  cursor: pointer;
  transition: color 0.15s ease;
}

.tab-button.active {
  color: #00d26a;
}

.tab-icon {
  font-size: 20px;
}

.tab-label {
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
```
  </action>
  <verify>TabBar component renders</verify>
  <done>TabBar component created</done>
</task>

<task type="auto">
  <name>Task 5: Update App.js with tabs and checklist view</name>
  <files>musicbingo_verify/src/App.js, musicbingo_verify/src/App.css</files>
  <action>
1. Update App.js to add tab navigation and checklist view:

```jsx
/**
 * Main App Component
 * Music Bingo QR Code Verification Scanner with Song Checklist
 */

import React, { useState, useEffect, useCallback } from 'react';
import Scanner from './components/Scanner';
import ResultDisplay from './components/ResultDisplay';
import ErrorMessage from './components/ErrorMessage';
import ServerConnect from './components/ServerConnect';
import { SongChecklist } from './components/SongChecklist';
import { TabBar } from './components/TabBar';
import { useScanner } from './hooks/useScanner';
import { useGameState } from './hooks/useGameState';
import { ApiClient } from './services/apiClient';
import { getApiUrl, setApiUrl, hasStoredUrl } from './config';
import './App.css';

function App() {
  const { result, error, isProcessing, handleScan, reset } = useScanner();
  const gameState = useGameState();
  const [serverUrl, setServerUrl] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [isCheckingConnection, setIsCheckingConnection] = useState(true);
  const [activeTab, setActiveTab] = useState('scan');

  // Check connection on mount
  useEffect(() => {
    async function checkConnection() {
      if (hasStoredUrl()) {
        const url = getApiUrl();
        const client = new ApiClient(url);
        const healthy = await client.healthCheck();
        if (healthy) {
          setServerUrl(url);
          setIsConnected(true);
        }
      }
      setIsCheckingConnection(false);
    }
    checkConnection();
  }, []);

  // Handle successful connection
  const handleConnect = useCallback((url) => {
    setApiUrl(url);
    setServerUrl(url);
    setIsConnected(true);
  }, []);

  // Handle game selection
  const handleGameChange = (e) => {
    const filename = e.target.value;
    if (filename) {
      gameState.loadGame(filename);
    }
  };

  // Show loading while checking initial connection
  if (isCheckingConnection) {
    return (
      <div className="app">
        <div className="processing-overlay" style={{ background: '#1a1a2e' }}>
          <div className="processing-content">
            <div className="spinner" />
            <p>Checking connection...</p>
          </div>
        </div>
      </div>
    );
  }

  // Show server connect screen if not connected
  if (!isConnected) {
    return (
      <div className="app">
        <ServerConnect onConnect={handleConnect} />
      </div>
    );
  }

  return (
    <div className="app with-tabs">
      {/* Tab Content */}
      <div className="tab-content">
        {activeTab === 'scan' && (
          <>
            {/* Header */}
            {!result && !error && (
              <header className="app-header">
                <h1>Music Bingo Verification</h1>
                <p>Scan QR code to check if you're a winner!</p>
              </header>
            )}

            {/* Scanner View */}
            {!result && !error && !isProcessing && (
              <Scanner
                onScan={handleScan}
                onError={(err) => {
                  console.error('Scanner error:', err);
                }}
              />
            )}

            {/* Processing Overlay */}
            {isProcessing && (
              <div className="processing-overlay">
                <div className="processing-content">
                  <div className="spinner" />
                  <p>Verifying...</p>
                </div>
              </div>
            )}

            {/* Result Display */}
            {result && (
              <ResultDisplay
                result={result}
                onClose={reset}
              />
            )}

            {/* Error Display */}
            {error && (
              <ErrorMessage
                message={error}
                onClose={reset}
              />
            )}
          </>
        )}

        {activeTab === 'checklist' && (
          <div className="checklist-container">
            {/* Game Selector Header */}
            <div className="checklist-header-bar">
              <select
                onChange={handleGameChange}
                value={gameState.currentGame?.name || ''}
                disabled={gameState.isLoading}
                className="game-select"
              >
                <option value="">Select a game...</option>
                {gameState.games.map(game => (
                  <option key={game.filename} value={game.filename}>
                    {game.name || game.filename}
                  </option>
                ))}
              </select>
            </div>

            {/* Loading State */}
            {gameState.isLoading && (
              <div className="loading-state">
                <div className="spinner" />
                <p>Loading game...</p>
              </div>
            )}

            {/* Error State */}
            {gameState.error && (
              <div className="error-state">
                {gameState.error}
              </div>
            )}

            {/* Song Checklist */}
            {!gameState.isLoading && (
              <SongChecklist
                songs={gameState.songs}
                playedSongs={gameState.playedSongs}
                onTogglePlayed={gameState.toggleSongPlayed}
                playedCount={gameState.playedCount}
                totalCount={gameState.totalCount}
              />
            )}
          </div>
        )}
      </div>

      {/* Tab Bar */}
      <TabBar
        activeTab={activeTab}
        onTabChange={setActiveTab}
      />
    </div>
  );
}

export default App;
```

2. Add to App.css (keep existing styles, add these):

```css
/* Tab layout */
.app.with-tabs {
  display: flex;
  flex-direction: column;
}

.tab-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* Checklist container */
.checklist-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

.checklist-header-bar {
  padding: 12px;
  background: #1a1a2e;
  border-bottom: 1px solid #2d2d44;
}

.game-select {
  width: 100%;
  padding: 12px;
  background: #2d2d44;
  border: 1px solid #3d3d5c;
  border-radius: 8px;
  color: #fff;
  font-size: 16px;
  -webkit-appearance: none;
}

.game-select:focus {
  outline: none;
  border-color: #00d26a;
}

.loading-state,
.error-state {
  padding: 40px 20px;
  text-align: center;
  color: #666;
}

.error-state {
  color: #ff6b6b;
}
```
  </action>
  <verify>npm start, tabs switch, checklist loads games, marking works</verify>
  <done>Scanner app updated with tabs and checklist view</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Tab bar switches between Scan and Checklist views
- [ ] Scan tab works exactly as before
- [ ] Checklist tab shows game selector
- [ ] Games load from API
- [ ] Song list displays with sort/search
- [ ] Marking songs syncs to API
- [ ] Polling updates from host changes
- [ ] Mobile-friendly touch interactions
</verification>

<success_criteria>
- Scanner PWA has two tabs: Scan (QR) and Songs (checklist)
- Both tabs functional on mobile device
- Checklist syncs with host app via API
- Fast search for finding songs when heard
- Same played indication as host (checkmark, dimmed, strikethrough)
</success_criteria>

<output>
After completion, create `.planning/phases/03-spotify-integration/03-03-SUMMARY.md`
</output>
