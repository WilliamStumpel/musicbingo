---
phase: 03-manual-playback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - musicbingo_cards/src/musicbingo_cards/csv_import.py
  - musicbingo_cards/src/musicbingo_cards/cli.py
  - musicbingo_cards/tests/test_csv_import.py
autonomous: true
---

<objective>
Add CSV playlist import to the card generator for Exportify-format files.

Purpose: Allow DJs to export their Spotify playlists via Exportify and import them into Music Bingo for card generation.

Output: New `import-csv` CLI command that converts Exportify CSV to game JSON format.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-spotify-integration/DISCOVERY.md
@musicbingo_cards/src/musicbingo_cards/cli.py
@musicbingo_cards/pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CSV import module</name>
  <files>musicbingo_cards/src/musicbingo_cards/csv_import.py</files>
  <action>
Create csv_import.py module to parse Exportify CSV files:

```python
"""
CSV Import for Exportify-format Spotify playlist exports.

Exportify (https://exportify.net) exports playlists with columns:
- Track Name (required)
- Artist Name(s) (required)
- Album Name (optional)
- Track Duration (ms) (optional)
- ISRC (optional, useful for cross-service lookup)
- Album Image URL (optional)
"""

import csv
import hashlib
from pathlib import Path
from typing import Optional


def generate_song_id(title: str, artist: str) -> str:
    """Generate a unique song ID from title and artist."""
    # Normalize and combine
    combined = f"{title.lower().strip()}|{artist.lower().strip()}"
    # Create short hash
    return hashlib.sha256(combined.encode()).hexdigest()[:12]


def parse_exportify_csv(csv_path: Path) -> list[dict]:
    """
    Parse an Exportify CSV file and return list of song dicts.

    Args:
        csv_path: Path to the CSV file

    Returns:
        List of song dicts with keys: song_id, title, artist, album, duration_ms, isrc

    Raises:
        ValueError: If required columns are missing
        FileNotFoundError: If CSV file doesn't exist
    """
    if not csv_path.exists():
        raise FileNotFoundError(f"CSV file not found: {csv_path}")

    songs = []

    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)

        # Validate required columns
        if reader.fieldnames is None:
            raise ValueError("CSV file is empty or has no headers")

        headers = [h.strip() for h in reader.fieldnames]

        # Check for required columns (case-insensitive)
        header_map = {h.lower(): h for h in headers}

        if 'track name' not in header_map:
            raise ValueError("CSV missing required column: 'Track Name'")
        if 'artist name(s)' not in header_map:
            raise ValueError("CSV missing required column: 'Artist Name(s)'")

        track_name_col = header_map['track name']
        artist_col = header_map['artist name(s)']
        album_col = header_map.get('album name')
        duration_col = header_map.get('track duration (ms)')
        isrc_col = header_map.get('isrc')

        for row in reader:
            title = row.get(track_name_col, '').strip()
            artist = row.get(artist_col, '').strip()

            if not title or not artist:
                continue  # Skip rows without title or artist

            song = {
                'song_id': generate_song_id(title, artist),
                'title': title,
                'artist': artist,
            }

            # Optional fields
            if album_col and row.get(album_col):
                song['album'] = row[album_col].strip()

            if duration_col and row.get(duration_col):
                try:
                    song['duration_ms'] = int(row[duration_col])
                except ValueError:
                    pass

            if isrc_col and row.get(isrc_col):
                song['isrc'] = row[isrc_col].strip()

            songs.append(song)

    return songs


def create_game_from_csv(
    csv_path: Path,
    game_name: str,
    output_path: Optional[Path] = None
) -> dict:
    """
    Create a game JSON structure from an Exportify CSV.

    Args:
        csv_path: Path to the Exportify CSV file
        game_name: Name for the game
        output_path: Optional path to write JSON file

    Returns:
        Game dict ready for JSON serialization
    """
    import json

    songs = parse_exportify_csv(csv_path)

    if len(songs) < 24:
        raise ValueError(
            f"Playlist has {len(songs)} songs, but at least 24 are required "
            f"for bingo cards (5x5 grid minus free space)"
        )

    game = {
        'game_name': game_name,
        'song_count': len(songs),
        'songs': songs
    }

    if output_path:
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(game, f, indent=2)

    return game
```
  </action>
  <verify>Import module, no syntax errors</verify>
  <done>CSV import module created with Exportify format support</done>
</task>

<task type="auto">
  <name>Task 2: Add import-csv CLI command</name>
  <files>musicbingo_cards/src/musicbingo_cards/cli.py</files>
  <action>
Add a new `import-csv` command to the CLI:

1. Import the csv_import module at the top of cli.py

2. Add new command:

```python
@cli.command()
@click.argument('csv_file', type=click.Path(exists=True, path_type=Path))
@click.option('-n', '--name', required=True, help='Name for the game')
@click.option('-o', '--output', type=click.Path(path_type=Path),
              help='Output JSON file path (default: games/<name>.json)')
def import_csv(csv_file: Path, name: str, output: Path | None):
    """
    Import a Spotify playlist from Exportify CSV format.

    Export your playlist at https://exportify.net, then import it here
    to generate bingo cards.

    Example:
        musicbingo import-csv my_playlist.csv -n "80s Hits Night"
    """
    from .csv_import import create_game_from_csv

    # Default output path
    if output is None:
        games_dir = Path('games')
        games_dir.mkdir(exist_ok=True)
        # Sanitize name for filename
        safe_name = "".join(c if c.isalnum() or c in ' -_' else '_' for c in name)
        safe_name = safe_name.replace(' ', '-').lower()
        output = games_dir / f"{safe_name}.json"

    try:
        game = create_game_from_csv(csv_file, name, output)
        click.echo(f"✓ Imported {game['song_count']} songs from {csv_file.name}")
        click.echo(f"✓ Game saved to {output}")
        click.echo(f"\nNext: Generate cards with:")
        click.echo(f"  musicbingo generate {output} -n 50 -o cards.pdf")
    except ValueError as e:
        click.echo(f"Error: {e}", err=True)
        raise SystemExit(1)
    except FileNotFoundError as e:
        click.echo(f"Error: {e}", err=True)
        raise SystemExit(1)
```
  </action>
  <verify>musicbingo import-csv --help shows the new command</verify>
  <done>CLI command added and working</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for CSV import</name>
  <files>musicbingo_cards/tests/test_csv_import.py</files>
  <action>
Create test file for CSV import functionality:

```python
"""Tests for CSV import from Exportify format."""

import pytest
from pathlib import Path
import tempfile
import csv

from musicbingo_cards.csv_import import (
    parse_exportify_csv,
    create_game_from_csv,
    generate_song_id,
)


class TestGenerateSongId:
    def test_consistent_ids(self):
        """Same title/artist should produce same ID."""
        id1 = generate_song_id("Never Gonna Give You Up", "Rick Astley")
        id2 = generate_song_id("Never Gonna Give You Up", "Rick Astley")
        assert id1 == id2

    def test_case_insensitive(self):
        """IDs should be case-insensitive."""
        id1 = generate_song_id("SONG TITLE", "ARTIST")
        id2 = generate_song_id("song title", "artist")
        assert id1 == id2

    def test_different_songs_different_ids(self):
        """Different songs should have different IDs."""
        id1 = generate_song_id("Song A", "Artist 1")
        id2 = generate_song_id("Song B", "Artist 2")
        assert id1 != id2


class TestParseExportifyCsv:
    def test_basic_import(self, tmp_path):
        """Test importing a basic CSV with required columns."""
        csv_file = tmp_path / "playlist.csv"
        csv_file.write_text(
            'Track Name,Artist Name(s),Album Name\n'
            'Song One,Artist A,Album X\n'
            'Song Two,Artist B,Album Y\n'
        )

        songs = parse_exportify_csv(csv_file)

        assert len(songs) == 2
        assert songs[0]['title'] == 'Song One'
        assert songs[0]['artist'] == 'Artist A'
        assert songs[1]['title'] == 'Song Two'

    def test_with_optional_fields(self, tmp_path):
        """Test importing CSV with optional fields."""
        csv_file = tmp_path / "playlist.csv"
        csv_file.write_text(
            'Track Name,Artist Name(s),Album Name,Track Duration (ms),ISRC\n'
            'Song One,Artist A,Album X,180000,USRC12345678\n'
        )

        songs = parse_exportify_csv(csv_file)

        assert songs[0]['album'] == 'Album X'
        assert songs[0]['duration_ms'] == 180000
        assert songs[0]['isrc'] == 'USRC12345678'

    def test_missing_required_column(self, tmp_path):
        """Test error when required column is missing."""
        csv_file = tmp_path / "playlist.csv"
        csv_file.write_text(
            'Track Name,Album Name\n'
            'Song One,Album X\n'
        )

        with pytest.raises(ValueError, match="Artist Name"):
            parse_exportify_csv(csv_file)

    def test_skips_empty_rows(self, tmp_path):
        """Test that rows with empty title/artist are skipped."""
        csv_file = tmp_path / "playlist.csv"
        csv_file.write_text(
            'Track Name,Artist Name(s)\n'
            'Song One,Artist A\n'
            ',Artist B\n'
            'Song Three,\n'
            'Song Four,Artist D\n'
        )

        songs = parse_exportify_csv(csv_file)

        assert len(songs) == 2
        assert songs[0]['title'] == 'Song One'
        assert songs[1]['title'] == 'Song Four'

    def test_file_not_found(self):
        """Test error when file doesn't exist."""
        with pytest.raises(FileNotFoundError):
            parse_exportify_csv(Path("/nonexistent/file.csv"))


class TestCreateGameFromCsv:
    def test_creates_game_structure(self, tmp_path):
        """Test that game structure is correct."""
        csv_file = tmp_path / "playlist.csv"

        # Create CSV with enough songs
        with open(csv_file, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Track Name', 'Artist Name(s)'])
            for i in range(30):
                writer.writerow([f'Song {i}', f'Artist {i}'])

        game = create_game_from_csv(csv_file, "Test Game")

        assert game['game_name'] == 'Test Game'
        assert game['song_count'] == 30
        assert len(game['songs']) == 30

    def test_too_few_songs(self, tmp_path):
        """Test error when playlist has fewer than 24 songs."""
        csv_file = tmp_path / "playlist.csv"
        csv_file.write_text(
            'Track Name,Artist Name(s)\n'
            'Song One,Artist A\n'
            'Song Two,Artist B\n'
        )

        with pytest.raises(ValueError, match="at least 24"):
            create_game_from_csv(csv_file, "Test Game")

    def test_writes_output_file(self, tmp_path):
        """Test that output file is written correctly."""
        csv_file = tmp_path / "playlist.csv"
        output_file = tmp_path / "game.json"

        with open(csv_file, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Track Name', 'Artist Name(s)'])
            for i in range(30):
                writer.writerow([f'Song {i}', f'Artist {i}'])

        create_game_from_csv(csv_file, "Test Game", output_file)

        assert output_file.exists()

        import json
        with open(output_file) as f:
            data = json.load(f)

        assert data['game_name'] == 'Test Game'
        assert len(data['songs']) == 30
```
  </action>
  <verify>pytest musicbingo_cards/tests/test_csv_import.py passes</verify>
  <done>Tests written and passing</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] csv_import.py module created
- [ ] import-csv CLI command works
- [ ] Exportify format CSV parses correctly
- [ ] Game JSON is generated with correct structure
- [ ] At least 24 songs required (validation works)
- [ ] Tests pass
- [ ] Output saved to games/ directory by default
</verification>

<success_criteria>
- DJ can export Spotify playlist via Exportify
- DJ runs `musicbingo import-csv playlist.csv -n "Game Name"`
- Game JSON created in games/ directory
- Game JSON compatible with existing card generator
- Songs have unique IDs for tracking played status
</success_criteria>

<output>
After completion, create `.planning/phases/03-spotify-integration/03-01-SUMMARY.md`
</output>
