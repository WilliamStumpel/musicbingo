---
phase: 03-manual-playback
plan: 04
type: execute
wave: 1
depends_on: ["03-01"]
files_modified:
  - musicbingo_api/src/musicbingo_api/main.py
  - musicbingo_api/src/musicbingo_api/schemas.py
  - musicbingo_api/src/musicbingo_api/game_service.py
autonomous: true
---

<objective>
Add API endpoints for marking songs as played/unplayed with toggle support.

Purpose: Enable both host and scanner apps to mark songs as played, with changes syncing to both devices via polling.

Output: POST /api/game/{id}/mark-song endpoint with toggle support, ensuring game state consistency.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-spotify-integration/DISCOVERY.md
@musicbingo_api/src/musicbingo_api/main.py
@musicbingo_api/src/musicbingo_api/schemas.py
@musicbingo_api/src/musicbingo_api/game_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mark-song schema</name>
  <files>musicbingo_api/src/musicbingo_api/schemas.py</files>
  <action>
Add request/response schemas for the mark-song endpoint:

```python
class MarkSongRequest(BaseModel):
    """Request to mark a song as played or unplayed."""
    song_id: str
    played: bool = True  # True to mark played, False to unmark


class MarkSongResponse(BaseModel):
    """Response after marking a song."""
    game_id: UUID
    song_id: str
    played: bool
    total_played: int
    updated_at: datetime
```

Add imports if needed (UUID, datetime, BaseModel).
  </action>
  <verify>Import schemas module without errors</verify>
  <done>Mark-song schemas added</done>
</task>

<task type="auto">
  <name>Task 2: Add toggle support to game service</name>
  <files>musicbingo_api/src/musicbingo_api/game_service.py</files>
  <action>
Add method to toggle song played status:

```python
def toggle_song_played(self, game_id: UUID, song_id: str, played: bool) -> Game:
    """
    Mark a song as played or unplayed.

    Args:
        game_id: The game ID
        song_id: The song ID to toggle
        played: True to mark as played, False to unmark

    Returns:
        Updated Game object

    Raises:
        ValueError: If game not found
    """
    game = self.get_game(game_id)
    if game is None:
        raise ValueError(f"Game {game_id} not found")

    if played:
        # Add to played songs if not already there
        if song_id not in game.played_songs:
            game.played_songs.append(song_id)
    else:
        # Remove from played songs if present
        if song_id in game.played_songs:
            game.played_songs.remove(song_id)

    game.updated_at = datetime.now()
    return game
```

Add datetime import if not present.
  </action>
  <verify>Method added without syntax errors</verify>
  <done>Toggle method added to game service</done>
</task>

<task type="auto">
  <name>Task 3: Add mark-song endpoint</name>
  <files>musicbingo_api/src/musicbingo_api/main.py</files>
  <action>
Add the POST /api/game/{game_id}/mark-song endpoint:

```python
@app.post(
    "/api/game/{game_id}/mark-song",
    response_model=MarkSongResponse,
    responses={400: {"model": ErrorResponse}, 404: {"model": ErrorResponse}},
)
async def mark_song(game_id: UUID, request: MarkSongRequest):
    """Mark a song as played or unplayed.

    This endpoint supports toggling - send played=true to mark as played,
    played=false to unmark. Useful for manual song tracking in both
    host and scanner apps.

    The played_songs array in game state is updated and can be polled
    via GET /api/game/{game_id}/state.
    """
    try:
        service = get_game_service()
        game = service.toggle_song_played(game_id, request.song_id, request.played)

        return MarkSongResponse(
            game_id=game.game_id,
            song_id=request.song_id,
            played=request.played,
            total_played=len(game.played_songs),
            updated_at=game.updated_at,
        )

    except ValueError as e:
        if "not found" in str(e).lower():
            raise HTTPException(status_code=404, detail=str(e))
        raise HTTPException(status_code=400, detail=str(e))
```

Import MarkSongRequest and MarkSongResponse from schemas.
  </action>
  <verify>Start server, test endpoint with curl</verify>
  <done>Mark-song endpoint added and working</done>
</task>

<task type="auto">
  <name>Task 4: Add songs array to LoadGameResponse</name>
  <files>musicbingo_api/src/musicbingo_api/schemas.py, musicbingo_api/src/musicbingo_api/main.py</files>
  <action>
The host and scanner apps need the songs array when loading a game.

1. Update LoadGameResponse schema to include songs:

```python
class SongInfo(BaseModel):
    """Song information for checklist display."""
    song_id: str
    title: str
    artist: str
    album: Optional[str] = None


class LoadGameResponse(BaseModel):
    """Response when loading a game file."""
    game_id: UUID
    name: str
    status: str
    card_count: int
    songs: list[SongInfo] = []  # Add this field
```

2. Update load_game endpoint to include songs in response:

```python
# In the load_game endpoint, after loading the game:
songs = [
    SongInfo(
        song_id=s.song_id,
        title=s.title,
        artist=s.artist,
        album=s.album
    )
    for s in game.playlist
]

return LoadGameResponse(
    game_id=game.game_id,
    name=filename.replace(".json", "").replace("-", " ").title(),
    status=game.status,
    card_count=len(game.cards),
    songs=songs,  # Add this
)
```
  </action>
  <verify>Load game, verify songs array returned</verify>
  <done>Songs array included in load game response</done>
</task>

<task type="auto">
  <name>Task 5: Test API endpoints</name>
  <files>None (testing only)</files>
  <action>
Verify all endpoints work correctly:

1. Start the API server:
```bash
cd musicbingo_api && uvicorn musicbingo_api.main:app --reload
```

2. Test load game (should include songs):
```bash
curl -X POST http://127.0.0.1:8000/api/games/load/test-game.json
```

3. Test mark song as played:
```bash
curl -X POST http://127.0.0.1:8000/api/game/{game_id}/mark-song \
  -H "Content-Type: application/json" \
  -d '{"song_id": "abc123", "played": true}'
```

4. Test get game state (should show played_songs):
```bash
curl http://127.0.0.1:8000/api/game/{game_id}/state
```

5. Test unmark song:
```bash
curl -X POST http://127.0.0.1:8000/api/game/{game_id}/mark-song \
  -H "Content-Type: application/json" \
  -d '{"song_id": "abc123", "played": false}'
```

6. Verify game state updated:
```bash
curl http://127.0.0.1:8000/api/game/{game_id}/state
```

All endpoints should return correct responses with updated state.
  </action>
  <verify>All curl commands return expected responses</verify>
  <done>API endpoints tested and working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MarkSongRequest/Response schemas added
- [ ] toggle_song_played method in GameService
- [ ] POST /api/game/{id}/mark-song endpoint works
- [ ] Marking song as played adds to played_songs
- [ ] Unmarking song removes from played_songs
- [ ] GET /api/game/{id}/state returns updated played_songs
- [ ] LoadGameResponse includes songs array
- [ ] No regressions in existing endpoints
</verification>

<success_criteria>
- Host app can mark songs via POST /api/game/{id}/mark-song
- Scanner app can mark songs via same endpoint
- Both can poll GET /api/game/{id}/state to sync
- Toggle works (can mark and unmark)
- Songs array available when loading game for checklist display
</success_criteria>

<output>
After completion, create `.planning/phases/03-spotify-integration/03-04-SUMMARY.md`
</output>
