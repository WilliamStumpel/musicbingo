---
phase: 07-prize-winner-tracking
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - musicbingo_api/src/musicbingo_api/models.py
  - musicbingo_api/src/musicbingo_api/schemas.py
  - musicbingo_api/src/musicbingo_api/game_service.py
  - musicbingo_api/src/musicbingo_api/main.py
  - musicbingo_verify/src/App.js
  - musicbingo_verify/src/components/CardRegistration.jsx
  - musicbingo_verify/src/components/CardRegistration.css
  - musicbingo_verify/src/services/apiClient.js
autonomous: true
---

<objective>
Implement card registration system so hosts can assign player names to cards when distributing them.

Purpose: Enable tracking of which player has which card, required for proactive winner detection.
Output: Backend API for card registration, Scanner UI for entering player names after scanning.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@musicbingo_api/src/musicbingo_api/models.py
@musicbingo_api/src/musicbingo_api/schemas.py
@musicbingo_api/src/musicbingo_api/game_service.py
@musicbingo_api/src/musicbingo_api/main.py
@musicbingo_verify/src/App.js
@musicbingo_verify/src/services/apiClient.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add registered_cards to GameState model</name>
  <files>musicbingo_api/src/musicbingo_api/models.py</files>
  <action>
Add a `registered_cards` field to the GameState dataclass. This should be a dict mapping card_id (UUID) to a registration dict containing:
- `player_name`: str - Name of the player
- `registered_at`: datetime - When the card was registered

Add it as: `registered_cards: dict[UUID, dict] = field(default_factory=dict)`

Also add a helper method `register_card(self, card_id: UUID, player_name: str)` that:
- Validates the card_id exists in self.cards
- Adds/updates the registration in registered_cards with player_name and current timestamp
- Returns the registration dict
  </action>
  <verify>Python syntax check: `python -c "from musicbingo_api.models import GameState"`</verify>
  <done>GameState has registered_cards field and register_card method</done>
</task>

<task type="auto">
  <name>Task 2: Add registration schemas</name>
  <files>musicbingo_api/src/musicbingo_api/schemas.py</files>
  <action>
Add request/response schemas for card registration:

```python
class RegisterCardRequest(BaseModel):
    """Request to register a card to a player."""
    card_id: UUID
    player_name: str = Field(..., min_length=1, max_length=50)

class RegisterCardResponse(BaseModel):
    """Response after registering a card."""
    card_id: UUID
    card_number: int
    player_name: str
    registered_at: datetime

class RegisteredCardInfo(BaseModel):
    """Info about a registered card."""
    card_id: UUID
    card_number: int
    player_name: str
    registered_at: datetime

class RegisteredCardsResponse(BaseModel):
    """Response listing all registered cards."""
    game_id: UUID
    cards: list[RegisteredCardInfo]
    total_registered: int
```
  </action>
  <verify>Python syntax check: `python -c "from musicbingo_api.schemas import RegisterCardRequest, RegisterCardResponse"`</verify>
  <done>Registration schemas defined</done>
</task>

<task type="auto">
  <name>Task 3: Add registration methods to GameService</name>
  <files>musicbingo_api/src/musicbingo_api/game_service.py</files>
  <action>
Add two methods to GameService:

1. `register_card(self, game_id: UUID, card_id: UUID, player_name: str) -> dict`:
   - Get game or raise
   - Validate card_id exists in game.cards
   - Call game.register_card(card_id, player_name)
   - Return dict with card_id, card_number, player_name, registered_at

2. `get_registered_cards(self, game_id: UUID) -> list[dict]`:
   - Get game or raise
   - Return list of dicts with card_id, card_number, player_name, registered_at for each registered card
   - Include card_number by looking up card in game.cards
  </action>
  <verify>Python syntax check: `python -c "from musicbingo_api.game_service import GameService"`</verify>
  <done>GameService has register_card and get_registered_cards methods</done>
</task>

<task type="auto">
  <name>Task 4: Add registration API endpoints</name>
  <files>musicbingo_api/src/musicbingo_api/main.py</files>
  <action>
Add two endpoints:

1. `POST /api/game/{game_id}/register-card`:
   - Request body: RegisterCardRequest (card_id, player_name)
   - Calls service.register_card()
   - Returns RegisterCardResponse
   - 404 if game or card not found
   - 400 if validation fails

2. `GET /api/game/{game_id}/registered-cards`:
   - Returns RegisteredCardsResponse with list of all registered cards
   - 404 if game not found

Import the new schemas at the top of the file.
  </action>
  <verify>Start server and test: `curl -X POST http://localhost:8000/api/game/{id}/register-card -H "Content-Type: application/json" -d '{"card_id": "...", "player_name": "Test"}'`</verify>
  <done>Registration endpoints return correct responses</done>
</task>

<task type="auto">
  <name>Task 5: Add registerCard to Scanner apiClient</name>
  <files>musicbingo_verify/src/services/apiClient.js</files>
  <action>
Add a new function to the apiClient:

```javascript
export async function registerCard(gameId, cardId, playerName) {
  const response = await fetch(`${getApiUrl()}/api/game/${gameId}/register-card`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ card_id: cardId, player_name: playerName }),
  });
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.detail || 'Failed to register card');
  }
  return response.json();
}
```
  </action>
  <verify>Check file syntax in browser dev tools or by running the app</verify>
  <done>apiClient exports registerCard function</done>
</task>

<task type="auto">
  <name>Task 6: Create CardRegistration component</name>
  <files>musicbingo_verify/src/components/CardRegistration.jsx, musicbingo_verify/src/components/CardRegistration.css</files>
  <action>
Create a CardRegistration component that appears after a successful scan (non-winner verification) to allow registering the card:

CardRegistration.jsx:
- Props: cardId, cardNumber, gameId, onRegistered, onCancel
- State: playerName (text input), isSubmitting, error
- Shows card number being registered
- Text input for player name (auto-focus)
- "Register" button (disabled if name empty or submitting)
- "Skip" button to cancel without registering
- On submit: call apiClient.registerCard(), then onRegistered(playerName)
- Show error message if registration fails

CardRegistration.css:
- Modal-style overlay (dark background)
- Centered card with white background
- Input field with large text for easy entry
- Green register button, gray skip button
- Mobile-friendly sizing (full width on small screens)
  </action>
  <verify>Component renders without errors in browser</verify>
  <done>CardRegistration component created with form and API integration</done>
</task>

<task type="auto">
  <name>Task 7: Integrate CardRegistration into Scanner App</name>
  <files>musicbingo_verify/src/App.js</files>
  <action>
Modify the Scanner App to show CardRegistration after a successful scan:

1. Add state: `registrationCard` (null or {cardId, cardNumber, gameId})
2. After verification response (in handleScan or result handler):
   - If card is NOT a winner and not already registered, set registrationCard with the card info
   - This triggers the registration modal to appear
3. Add CardRegistration component to render:
   - Show when registrationCard is not null
   - onRegistered: clear registrationCard, optionally show success toast
   - onCancel: clear registrationCard, return to scanning

The flow becomes: Scan → Verify → If not winner, show registration option → Register or Skip → Back to scanning

Import CardRegistration at the top.
  </action>
  <verify>Full flow test: scan a card, see registration modal, enter name, submit, return to scanning</verify>
  <done>Scanner app shows registration option after scanning non-winner cards</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Backend: `POST /api/game/{id}/register-card` registers card with player name
- [ ] Backend: `GET /api/game/{id}/registered-cards` returns all registered cards
- [ ] Scanner: After scanning, registration modal appears
- [ ] Scanner: Can enter name and register card
- [ ] Scanner: Can skip registration and return to scanning
- [ ] No TypeScript/Python errors
</verification>

<success_criteria>
- All tasks completed
- Card registration API endpoints functional
- Scanner app allows registering player names to cards
- Registration data persists in game state
</success_criteria>

<output>
After completion, create `.planning/phases/07-prize-winner-tracking/07-01-SUMMARY.md`
</output>
